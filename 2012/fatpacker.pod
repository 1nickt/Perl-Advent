Title: Self-contained applications
Topic: fatpack / App::FatPacker

=head1 In No-Dependency Land

While the proliferation of solutions like L<local::lib> and L<cpanminus> has
made it a breeze to manage dependencies, there are still some rare occassions
in which we need to be able to ship code that has no external non-core
dependencies.

There are a few existing solutions for them, but we're going to concentrate
on a new one called B<FatPacker>.

=head1 Packing the deps

L<App::FatPacker> comes with an application called F<fatpack>.  You'll use
F<fatpack> to get at all of App::FatPacker's features.  There are four simple
steps for packing your dependencies. Let's go over them.

=over

=item * Tracing

To find out what dependencies our code has, we C<trace> our script. This will
create a file called F<fatpacker.trace>, which includes a list of modules that
F<fatpack> has discovered.

    #!code
    $ fatpack trace myscript.pl

In case some modules aren't successfully traced, you can ask C<fatpack> to
include them:

    #!code
    $ fatpack trace --use=Additional::Module myscript.pl

=item * Gathering packlists

Packlists are files that distributions install.  They contain information on
which modules are included in the distribution. FatPacker needs to find the
packlist for each module in order to make sure it includes all dependencies
recursively and does not miss anything. One module is likely to use another
module, which might use another module in turn, and so on.

We can call C<packlists-for> with a list of modules, or we can feed it the
content of the trace output we created with the previous command. It will print
out a list of all the packlists, which we'll simply redirect to a file so we
can reuse this information.

    #!code
    $ fatpack packlists-for `cat fatpacker.trace` > packlists

=item * Forming the tree

In this step FatPacker collects all the dependencies recursively into a
directory called F<fatlib>, which it will then be able to pack together.

XXX - I am confused by the following paragraph: -- rjbs, 2012-11-27

We will be feeding the command the packlists the previous command has printed
using the file we saved earlier.

    #!code
    $ fatpack tree `cat packlists`

=item * Packing dependencies

Once we have all our dependencies in a directory, we can finally pack it all
nicely using the last command: C<file>. This command packs all the
modules in the current F<fatlib> directory. It will also try to pack any F<lib>
directory that exists in the current directory. If none is present, you will
need to create it.

Since the command only packs the modules, we're still missing our code that
uses them, so we will concatenate that as well. We will also print this to a
new file so we could ship it.

    #!code
    $ (fatpack file; cat myscript.pl) > myscript.packed.pl

That's all there is to it!

You can now ship F<myscript.packed.pl> to any location, and it will include all
dependencies recursively.

=back

=head1 It's already being used!

There is at least one famous project which uses this method to create a
self-contained program: L<cpanminus> proved this method to be useful for
beginners and seasoned system administrators in providing a self-contained
full-fledged CPAN client, always available at your finger-tips without any
installations required (other than having a Perl interpreter, of course).

You can always download a packed C<cpanminus> program and use it, wherever
you are, using the following command:

    #!code
    $ curl -kL cpanmin.us > cpanm
    $ perl cpanm Some::Module

=head1 Caveat

There are some considerations still:

=over

=item * Compile time code will be run

If you have any compile-time code (think C<BEGIN> blocks), they will be run
as part of the tracing step. Generally, these aren't recommended for most use
cases anyway.

If you have any compile-time code which shouldn't run upon tracing, you might
want to consider refactoring it into run-time code.

=item * Lazily loaded modules won't be found

Any modules that are loaded lazily (such as C<require> statements) will not
be traced successfully. You can, however, provide them as additional modules
for the C<trace> command, as described above.

=item * XS modules are not supported

L<App::FatPacker> only supports Pure-Perl modules, so if you're using any XS
modules, you'll need to have them installed remotely.

=back

