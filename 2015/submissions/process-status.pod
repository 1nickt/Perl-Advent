Title:  No More Leaking Glue
Topic:  Process::Status
Author: Ricardo SIGNES <rjbs@cpan.org>

Perl is often used as a "glue language."  You have a bunch of other programs
that you want to automate from one place, so you use Perl.  You put the
programs carefully in position, grab the bottle of Krazy Glue, drizzle it
everywhere, and bask in the glow of what you've accomplished.

Only then, in evitably, you can't put down the glue.  It's not that you've gone
mad with a need to automate all the things — although that's a possibility,
too.  This time, though, you've glued the glue to your hand, and no matter what
those people on the GlueGaffes subreddit tell you, the only way to get that
bottle off your hands is to become some sort of snake monster and shed your
skin.  This, presumably, is how Python programmers come to be.

Well, the leak in our gluey Perl might not be so bad, but it's still a big
annoyance.  It's all those places where Perl reminds you, "Hey!  Hey!  Lots of
me is just a little wrapper around C library stuff!"  Isn't that great?

This is why you end up with `stat` returning a thirteen element list, for
example. Wait, the Perl Advent Calendar has never mentioned L<File::stat>?
Well, check it out later, because that's not the problem we're talking about
right now.

Right now, I'm thinking about running subprocesses.  There are a number of ways
to do this.  You might use C<system>.  You might use C<open>.  You might use
C<fork>.  They all have one thing in common: when the process you started via
those means exits, you get its exit status in the same place: C<$?>

C<$?> (known by devotees of the L<Way of the
Dog|http://www.amazon.com/Perl-Best-Practices-Damian-Conway/dp/0596001738> as
C<$CHILD_STATUS>) gets populated with the numeric status of the ex-process.
It's supposed to be easy to remember C<$?> because it's the same name as in
shell programming… but in the shell, C<$?> is the exit value of the program.
If a program exits 75, then C<$?> is 75.  In Perl, that would be 19200... and
now you just glued your finger to the keyboard.

Perl is leaking the way that status day is packed into the status integer in C:
eight bits of exit value, seven bits of signal identifier, and one bit to flag
whether the process dumped core.  Instead of giving you three variables, you
get one number between 0 and 65535.  Great!

In C, there are macros for getting the data you wanted.

  #!vim c
  exit_status = WEXITSTATUS(status);
  signal      = WTERMSIG(status);
  exit_status = WCOREDUMP(status);

In Perl, you typically find people doing this:

  #!perl
  return unless system($some_command);

  die sprintf "program exited %i", $? << 8;

...which we tend to recognize at a glance, and don't notice how ridiculous it
is to type this all the time.

We also probably don't notice when the code accidentally uses C<<< << >>>
instead of C<<< >> >>>, either.  Did you?

We I<also> also probably don't think about the fact that we might care about
the signal, but totally failed to check or print it there.  Why did we fail to
do that?  Maybe because it was more work, and maybe because we have a quota of
one bitwise operation allowed per Perl program per day, and we hit it with the
first one.

Of course, we can eliminate these stupid errors with everyone's favorite core
module… POSIX!

  #!perl
  use POSIX qw(WEXITSTATUS);

  return unless system($some_command);

  die sprintf "program exited %i", WEXITSTATUS($?);

Ha ha just kidding.  I mean, you I<could> do that, but then you'd be using
POSIX.pm, and you'd have to hit shift a whole lot, I<and> you'd have to
remember to add that code for signals!  Also, seriously, I<POSIX.pm>.

This is why Process::Status exists.  It's such a useful module that Ruby stole
it from us, then traveled back in time 15 years to make it look like they wrote
it first.

  #!perl
  use Process::Status;

  system($some_command);
  Process::Status->assert_ok;

If your program exited 0, nothing happens.  If it exited non-zero, you get an
exception like:

  program exited 13, caught SIGWOOP; dumped core at line...

There are a bunch of other useful methods for finer-grained handling, but for
the most part the only three you need to know are self-explanatory:

=for :list
* as_string
* assert_ok
* is_success

If you ever run subprocesses from Perl, use Process::Status.

If you don't ever run subprocesses from Perl, I don't even understand your
life.
