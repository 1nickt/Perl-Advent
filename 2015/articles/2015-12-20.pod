Title:  Perl and Redis
Topic:  Redis::Fast Cache::Redis Redis::LeaderBoard Redis::Namespace
Author: Masayuki Matsuki <songmu@cpan.org>

Redis is high performance in memory Key Value store and known as data structure server. It is very useful for not only cashing but als susppo rstuss pmpaon yr sdtautsas pm psaeotns  yso, has affinity with our application codes. We can use redis variables as "super global variables". It is very useful and powerful (and dangerous :p).

L<< Redis's documentation| http://redis.io/documentation >> is very full and we can try the commands in L<< interactive console|http://redis.io/commands>> on web browser!

I introduce the CPAN modules around redis.

=head2 L<Redis::Fast>

L<Redis::Fast> is a client module for Redis. It has Redis.pm compatible interfaces using XS, so "Fast".

Redis.pm is pure perl implementation so, stable and easy to understand, but little a bit slow, especially for cashing.

In my work (online games, SNS and so on), Redis::Fast is also stable and very fast, so you can use Redis::Fast instead of Redis.pm in relief.

    my $redis = Redis::Fast->new;
    $redis->incr('blah');

=head2 L<Cache::Redis>

I want to use Redis as caching storage and I wrote L<Cache::Cache> compatible interface client library for Redis.

    my $redis = Redis::Fast->new; # you can use Redis.pm too.
    my $cache = Cache::Redis->new(redis => $redis);
    $cache->set(blah => 1);
    say $cache->get('blah'); # 1

By using Cache::Redis, we can easily replace cache storage in application code layer.

=head2 L<Redis::LeaderBoard>

Redis's "sorted set" is very useful for creating leaderboards but, which don't return "unique" rank (cf. L<https://github.com/antirez/redis/issues/943>>). So I wrote the ranking module using Redis which care "unique" rank.

    use Redis::Fast;
    use Redis::LeaderBoard;
    my $redis = Redis::Fast->new;
    my $lb = Redis::LeaderBoard->new(
        redis => $redis,
        key   => 'leader_board:1',
        order => 'asc', # asc/desc, desc as default
    );
    $lb->set_score(one => 100);
    $lb->set_score(two =>  50);
    my ($rank, $score) = $lb->get_rank_with_score('one'); #=> (1, 100)

I introduce a technique. That is "using epoch as score".

    my $lb = Redis::LeaderBoard->new(
        redis => $redis,
        key   => 'recent_post',
        limit => 20,
    );
    $lb->set_score($url, $updated->epoch);
    ...
    # you can get recent posts up to 20 entries
    my $recent_posts = $lb->rankings;

=head2 L<Redis::Namespace>

Generally, key management of the KVS is very difficult and confusing (easy to conflict, typo and so on). KVS is very cool, but it is "super global variables store"  in almost, so we must appropriately manage them.

We can use Redis::Namespace for better key name managements.

    my $redis = Redis::Fast->new;
    my $ns = Redis::Namespace->new(redis => $redis, namespace => 'ranking');
    $ns->set(foo => 'bar');    # will call $redis->set('fugu:foo', 'bar');
    my $foo = $ns->get('foo'); # will call $redis->get('fugu:foo');

The object of Redis::Namespace fill up the prefix namespace automatically.

I recommend the all redis objects are wrapped by Redis::Namespace.
