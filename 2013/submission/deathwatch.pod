Title: Ask not for whom the (Christmas) bell tollsâ€¦
Topic: Win32::OLE and Deathwatch
Author: Ricardo Signes <rjbs@cpan.org>

=head2 Perl on Win32

For quite a while, I wrote code on Windows as my day job.  As a
dyed-in-the-wool Unix fan, I did a lot of grumbling about not all the comforts
of my favorite operating system.  I missed quite a few things, but Perl wasn't
one of them.  Perl worked very well on Windows, and most of the problems I
encountered were easy to fix, because they were little niggles like backslashes
or line endings.  I soldiered on comfortably until the day I first discovered
Win32::OLE.  From that point on, I delighted myself every day by automating
more annoying tasks with Perl.

Win32::OLE lets you automate any scriptable Windows program with Perl.  For
example, you can muck about with an Excel spreadsheet:

  #!perl
  my $xl_app  = Win32::OLE->new("Excel.Application");
  my $xl_book = $xl_app->Workbooks->Add;

  $xl_book->{Name} = "Annual Report";

  my $sheet = $xl_book->Worksheets(1);

  $sheet->{Name} = "Report Version";
  $sheet->Range("A1:B2")->{Value} = [
    [ "Generated by", __PACKAGE__ ],
    [ "Generated on", scalar localtime ]
  ];

I used this to produce do all kinds of things, although Excel was definitely my
most-automated tool.

Rather than talk about Excel, though, I thought I should talk about something
more Christmassy:  the deep, looming fear of losing one's job just before the
holidays and being left out in the cold.

=head2

There I was


  use Win32::OLE;

  use strict;
  use warnings;

  =head1 NAME

  Deathwatch -- poll Active Directory for unexpected emancipations

  =head1 CONFIGURATION

  A few package variables must be set: C<$ADsPath> is the Active Directory path
  (in LDAP format, for use in ADSI) in which to look for users and C<$cachefile>
  is the name of a file used to store the cache.

  =cut

  our $ADsPath   = "LDAP://OU=Employees,DC=your,DC=company,DC=com";
  our $cachefile = "users.txt";
  our (@cache, %cache_seen);

  =head1 SUBROUTINES

  =over

  =item C< adsi_connection >

  This routine returns an ADODB.Connection object created with Win32::OLE.

  =cut

  sub adsi_connection {
    my $c = Win32::OLE->new("ADODB.Connection");
    $c->{Provider}="ADsDSOObject";
    $c->Open("ADSI Provider");
    die Win32::OLE->LastError() if Win32::OLE->LastError();
    return $c;
  }

  =item C< read_cachefile >

  This routine reads the cache file into the cache.

  =cut

  sub read_cachefile {
    open UL, '<', $cachefile or return;
    my @users;
    while (<UL>) {
      chomp;
      next if /^\s*(#|$)/;
      push @users, $_;
    }
    close UL;

    update_cache(@users);
  }

  =item C< update_cachefile(@users) > 

  This routine appends the passed usernames to the cache file.

  =cut

  sub update_cachefile {
    my @users = @_;
    open UL, '>>', $cachefile;
    print UL "$_\n" for @users;
    close UL;
    @users;
  }

  =item C< update_cache(@users) >

  Given a list of users, this routine adds the users to the cache.

  =cut

  sub update_cache {
    my @users = @_;
    $cache_seen{$_} = 1 for @users;
    @cache = (@cache, @users);
    @users;
  }

  =item C< is_cached($user) >

  This is true if the given user is in the cache.

  =cut

  sub is_cached {
    my $user = shift;
    return 1 if $cache_seen{$user};
  }

  =item C< user_rs >

  C<user_rs> returns an ADO recordset via Win32::OLE, querying C<$ADsPath> for
  all users.

  =cut

  sub user_rs {
    my $c = adsi_connection;
    my $rs = $c->Execute("
      SELECT cn, objectClass, userAccountControl
      FROM '$ADsPath' WHERE objectClass='User'
    ");
    die Win32::OLE->LastError() if Win32::OLE->LastError();

    $rs;
  }

  =item C< find_new >

  Gets a user recordset from C<user_rs>, then eliminates irregular accounts, 
  enabled accounts, and accounts in the cache.  The rest are returned as its
  findings.

  =cut

  sub find_new { 
    my @findings;
    my $rs = user_rs;

    until ($rs->EOF) {
      push @findings, $rs->Fields(2)->{Value}
        if (($rs->Fields(0)->{Value} & 514 & 2) and (!is_cached($rs->Fields(2)->{Value})));
      $rs->MoveNext;
    }

    @findings;
  }

  =item C< announce($found_in, @findings) >

   announce('ADSI poll',@userlist);

  This prints "found in ADSI poll at Mon Jul 28 12:00:00 2004" followed by the
  names in C<@findings>.  Users with no spaces in their names are ignored, under
  the assumption that they are not real users.

  =cut

  sub announce {
    my ($found_in, @findings) = @_;
    return unless @findings;
    print "\n==> found in $found_in at " . localtime() . "\n";
    print "$_\n" for grep / /, @findings;
  }

  ##
  ## THE DEATH WATCH BEGINS
  ##

  # quit when asked to
  sub quit { print "\nDone.\nAsk not for whom the bell tolls.\n"; exit }

  $SIG{INT} = \&quit;

  # fetch the cached names and announce them
  announce(cache => read_cachefile);

  # until interrupted, check for new findings, cache them, and announce them
  while (1) {
    if (my @findings = find_new) {
      update_cachefile(update_cache(@findings));
      announce(directory => @findings);
    } else {
      local $| = 1;
      print ".";
    }
    sleep(10);
  }

  =head1 AUTHOR

  Ricardo SIGNES E<lt>rjbs@cpan.orgE<gt>

  =head1 COPYRIGHT

  This code was written in 2003-2004.  I have released it into the public domain.  

  =cut

